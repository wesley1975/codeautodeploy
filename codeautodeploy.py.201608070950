#!/usr/bin/python
# -*- coding: utf-8 -*-
########################################################################
# Name:
# 		ServiceAutoUpdate.py  (service auto update script)
# Description:
# 		Periodically pull the package from the specific site and update
# Author:
# 		wuwesley
# Python:
#       2.7
# Version:
#		1.0
########################################################################

import os, time, re, logging, ConfigParser, urllib2
import subprocess,shutil
import sys,telnetlib
import threading

#==================Function Define =====================================
#==================define the global variables ========================
# the url of remote package, such as: https://s3.amazonaws.com/wuwesley/flashsales/EurekaServer-0.0.1-SNAPSHOT.jar
mRemotePackageUrl = ''
# the file that contains the version info of the package. such as: https://s3.amazonaws.com/wuwesley/flashsales/EurekaServer-0.0.1-SNAPSHOT.jar.inof
mRemotePackageVer = ''
# the configuration file for the tools
mConfFile = 'ServiceAutoUpdate.cfg'
# the log file for the tools
mLogFile = 'ServiceAutoUpdate.log'
# the directory that contains the installed package
mLocalInstallationPath = ''
# the package name in local environment
mLocalPackageName = ''
# the host name of the service
mServiceHost = 'localhost'
# the port of the service
mServicePort= ''
# the current version of the running package
mCurrentVersion = 0
# the new version no
mNewVersion = 0
# the global logger object
mLogger = ''
# the configuration section
mSection = 'ServiceAutoUpdate'
# the name of the service
mServiceName =''
# the threshold that indicate the service is unhealth
mThreshold =5
# the thread for the service update
mUpdateServiceThread = ''
# timeout for the update thread , unit is seconds
mThreadTimeout = 600
# get the current time in seconds
current_seconds_time = lambda: int(round(time.time() * 1000*1000))
# the start time of the thread
mThreadStartTime = current_seconds_time()



# initialize the logger object
def init_the_logger():
    global mLogger, mLogFile
    # create logger with log file
    mLogger = logging.getLogger('ServiceAutoUpdate')
    mLogger.setLevel(logging.INFO)
    mLoggerFileHandler = logging.FileHandler(mLogFile)
    mLoggerFileHandler.setLevel(logging.INFO)
    # create formatter and add it to the handlers
    mLogFormatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    mLoggerFileHandler.setFormatter(mLogFormatter)
    # add the handlers to the logger
    mLogger.addHandler(mLoggerFileHandler)


# update the value for the specific key
# **keyv : AutoLogin='False'
def change_config_by_key(mConfFile, section, **keyv):
    mConfig = ConfigParser.ConfigParser()
    mConfig.read(mConfFile)
    [mConfig.set(section, key, keyv[key]) for key in keyv if mConfig.has_option(section, key)]
    mConfig.write(open(mConfFile, 'w'))


# read and update the global variable in memory
def read_cofig_file_to_memory():
    global mRemotePackageUrl, mRemotePackageVer, mLocalInstallationPath,mLocalPackageName
    global mServiceName, mServicePort, mCurrentVersion, mSection
    mConfig = ConfigParser.SafeConfigParser()
    mConfig.read(mConfFile)
    mRemotePackageUrl = mConfig.get(mSection, 'RemotePackageUrl')
    mRemotePackageVer = mConfig.get(mSection,'RemotePackageVer')
    mLocalInstallationPath = mConfig.get(mSection, 'LocalInstallationPath')
    mLocalPackageName = mConfig.get(mSection, 'LocalPackageName')
    mServiceName = mConfig.get(mSection, 'ServiceName')
    mServicePort = mConfig.get(mSection, 'ServicePort')
    mCurrentVersion = mConfig.get(mSection, 'CurrentVersion')


# update the version to the config file
def uptdat_current_verion_value():
    global mNewVersion,mCurrentVersion,mLogger
    if  long(mCurrentVersion) != 0 and long(mNewVersion) != 0 and long(mCurrentVersion) < long(mNewVersion):
        change_config_by_key(mConfFile, mSection, CurrentVersion=mNewVersion)
        # update the current version, keep updating
        mCurrentVersion = mNewVersion
        mLogger.info("Update the CurrentVersion: %s" % mCurrentVersion)



# get the latest version info from the remote package info url
def get_latest_package_info():
    global mRemotePackageVer, mNewVersion, mLogger
    if mRemotePackageVer =='': return False
    info_fp = urllib2.urlopen(mRemotePackageVer, None, 30)
    info = info_fp.read()
    if info and len(info) != 0:
        mNewVersion = info
        info_fp.close()
        mLogger.info("Find the new version: %s" % mNewVersion)
        return True
    else:
        info_fp.close()
        return False

# print the message to console
def print_progress_bar(message):
    sys.stdout.write(message)
    sys.stdout.flush()


# get the latest package from the remote package  url
def download_latest_package():
    global mRemotePackageUrl,mLogger, mLocalPackageName
    data_size = 0
    if mLocalPackageName == '': mLocalPackageName = mRemotePackageUrl.split('/')[-1]
    dest_file = mLocalPackageName
    try:
        data_file = urllib2.urlopen(mRemotePackageUrl, None, 30)
        data_size = int(dict(data_file.headers).get('content-length'))
    except urllib2.HTTPError, e:
        mLogger.info("Not found package for uri: %s" % mRemotePackageUrl)
        return False

    fp = open(dest_file, 'ab')

    read_unit_size = 1048576  # read at most 1M every time
    read_size = 0
    bar_length = 70  # print 70 '='
    speed_max_length = 11  # for example, 1023.99KB/s

    mLogger.info("Package downloading...\nLength: %s bytes\nSaving to %s" % (data_size, dest_file))
    start_time = time.time()
    while read_size < data_size:
        read_data = data_file.read(read_unit_size)
        fp.write(read_data)
        read_size += len(read_data)
        progress_bar = '=' * int(float(read_size) / data_size * bar_length)

        download_time = int(time.time() - start_time) + 1
        download_percent = int(float(read_size) / data_size * 100)
        blank_bar = " " * (bar_length - len(progress_bar))
        #read_size_str = format(read_size, ',')
        read_size_str = str(read_size)

        download_speed = float(read_size) / download_time
        if download_speed >= 1024 * 1024:
            download_speed = format(download_speed / (1024 * 1024), '.2f') + 'M'  # MB/s
        elif download_speed >= 1024:
            download_speed = format(download_speed / 1024, '.2f') + 'K'  # KB/s
        else:
            download_speed = format(download_speed, '.2f')  # B/s

        speed_blanks = ' ' * (speed_max_length - len(download_speed) - len('B/s'))
        print_progress_bar(str(download_percent) + "% [" + progress_bar +
                           ">" + blank_bar + "] " + read_size_str + "  " + speed_blanks +
                           download_speed + "B/s\r")

    print_progress_bar("\n")
    mLogger.info("Download complete.")
    fp.close()
    data_file.close()
    return True

#  Check whether the given host:port is accessable or not.
def check_service_status():
  global mServiceHost,mServicePort,mLogger
  t = telnetlib.Telnet()
  try:
    t.open(mServiceHost, mServicePort)
  except:
    mLogger.info("The service may be down!")
    return False
  t.close()
  mLogger.info("The service is alive!")
  return True


# stop the service
def stop_the_service():
    global mLogger,mServiceName
    command = ['sudo', 'service', mServiceName, 'stop']
    mLogger.info('Executing: %s' % command)
    subprocess.call(command, shell=False)
    time.sleep(20)


# start the service
def start_the_service():
    global mLogger,mServiceName
    command = ['sudo', 'service', mServiceName, 'start']
    mLogger.info('Executing: %s' % command)
    subprocess.call(command, shell=False)
    time.sleep(20)


# copy the file from src to dest, the dest should be /dir/to/file.jar
def copyfile_from_src_to_dest(src, dest):
    global mLogger
    if not os.path.exists(src):
        # Some bad symlink in the src
        mLogger.warn('Cannot find file %s (bad symlink)', src)
        return
    if os.path.exists(dest):
        mLogger.debug('File %s already exists', dest)
        return
    if not os.path.exists(os.path.dirname(dest)):
        mLogger.info('Creating parent directories for %s', os.path.dirname(dest))
        os.makedirs(os.path.dirname(dest))
    mLogger.info('Copying %s to %s', src, dest)
    shutil.copy2(src, dest)


# make file executable
def make_file_executable(fn):
    global mLogger
    if hasattr(os, 'chmod'):
        oldmode = os.stat(fn).st_mode & 0xFFF # 0o7777
        newmode = (oldmode | 0x16D) & 0xFFF # 0o555, 0o7777
        os.chmod(fn, newmode)
        mLogger.info('Changed mode of %s to %s', fn, oct(newmode))

# update the service
def update_the_service():
    global mRemotePackageVer, mNewVersion, mCurrentVersion,mLocalInstallationPath,mLocalPackageName
    # compare the current version and new version
    get_latest_package_info()
    if long(mCurrentVersion) == 0 or long(mNewVersion) == 0 or long(mCurrentVersion) == long(mNewVersion): return
    # download the new package
    if download_latest_package() == False: return
    # stop the service
    stop_the_service()
    # copy downloaded file to dest path
    mDest = mLocalInstallationPath+'/'+mLocalPackageName
    copyfile_from_src_to_dest(mLocalPackageName, mDest)
    # make it executable
    make_file_executable(mDest)
    # start the service
    start_the_service()

# keep the service alive
def keep_the_service_alive():
    global mThreshold
    mUnhealth = 0
    for mCount in range(0,mThreshold):
        if check_service_status() == False : mUnhealth +=1
        else : break
        time.sleep(10)
    if mUnhealth == mThreshold:
        stop_the_service()
        start_the_service()


# in order to avoid to block the main  event loop, start the update task in another thread
def start_update_service_thread():
    global mUpdateServiceThread,mThreadStartTime,mLogger
    mThreadStartTime = current_seconds_time()
    mUpdateServiceThread = threading.Thread(target=update_the_service)
    mUpdateServiceThread.daemon = True
    mUpdateServiceThread.start()
    mLogger.info('Start the service update thread: %s', mUpdateServiceThread.getName())


#=============Begin the main logic =====================
# initilize the logger
init_the_logger()

# read the configuration
read_cofig_file_to_memory()


# enter the main loop
while True:
    # keep the service alive
    keep_the_service_alive()
    # check the current running thread of service update
    if not mUpdateServiceThread is None:
        if mUpdateServiceThread.isAlive() == True:
            if current_seconds_time() - mThreadStartTime < mThreadTimeout:continue
            else: mUpdateServiceThread.join()
    # run the update service
    update_the_service()
    # hava a sleep
    time.sleep(60)